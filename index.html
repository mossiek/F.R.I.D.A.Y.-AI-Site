<!doctype html>
u.onstart = () => { if(hud){ hud.classList.add('speaking'); } if(core){ core.style.animation = 'coreThrob 1.2s ease-in-out infinite'; } };
const cleanup = () => { if(hud){ hud.classList.remove('speaking'); } if(core){ core.style.animation = ''; } };
u.onend = cleanup; u.onerror = cleanup; u.onpause = cleanup;
speechSynthesis.cancel();
speechSynthesis.speak(u);
}
speechSynthesis.cancel();
speechSynthesis.speak(u);
}
// Ensure voices are loaded on some browsers
speechSynthesis.onvoiceschanged = () => {};


/***********************
* 5) BROWSER STT (Voice → Text)
***********************/
let recognizer = null;
let listening = false;
let wakeArmed = false;
let postWakeTimer = null;


function supportsRecognition() {
return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
}


function buildRecognizer() {
const R = window.SpeechRecognition || window.webkitSpeechRecognition;
const rec = new R();
rec.continuous = true;
rec.interimResults = true;
rec.lang = navigator.language || 'en-US';
rec.onstart = () => setStatus('Mic listening…');
rec.onerror = (e) => setStatus('Mic error: ' + (e.error||'unknown'));
rec.onend = () => { setStatus('Mic idle'); listening = false; };
rec.onresult = (ev) => {
let lastFinal = '';
for (let i = ev.resultIndex; i < ev.results.length; i++) {
const r = ev.results[i];
const t = r[0].transcript.toLowerCase().trim();
if (r.isFinal) lastFinal = t;
// Wake word detect from interim or final
if (toggleWake.checked && wakeArmed && t.includes(CONFIG.WAKE_WORD)) {
wakeArmed = false; // disarm
micBtn.classList.add('pulse');
setStatus('Wake word heard. Speak your request…');
clearTimeout(postWakeTimer);
postWakeTimer = setTimeout(() => {
micBtn.classList.remove('pulse');
const cleaned = (lastFinal||'').replace(CONFIG.WAKE_WORD, '').trim();
if (cleaned) handleUserText(cleaned);
wakeArmed = true; // re-arm for next time
setStatus('Ready');
}, CONFIG.AUTO_LISTEN_AFTER_WAKE_MS);
}
}
};
return rec;
}


function ensureRecognizer() { if (!recognizer) recognizer = buildRecognizer(); }


// Mic button behavior: first click arms continuous wake‑word mode; click again for push‑to‑talk burst
micBtn.addEventListener('click', async () => {
if (!supportsRecognition()) {
alert('Your browser does not support Speech Recognition. Try Chrome or Edge on desktop.');
return;
}
ensureRecognizer();
if (!listening) {
recognizer.start();
listening = true;
wakeArmed = true;
setStatus('Listening (wake word armed)…');
} else {
// Push‑to‑talk: capture a short utterance
wakeArmed = false;
setStatus('Push‑to‑talk: speak now…');
try { recognizer.stop(); } catch {}
ensureRecognizer();
const R = window.SpeechRecognition || window.webkitSpeechRecognition;
const single = new R();
single.continuous = false;
single.interimResults = false;
single.lang = navigator.language || 'en-US';
single.onresult = (ev)=>{ const t = ev.results[0][0].transcript.trim(); if (t) handleUserText(t); };
single.onend = ()=>{ setStatus('Listening (wake word armed)…'); wakeArmed = true; try { recognizer.start(); listening = true; } catch {} };
single.start();
}
});


/***********************
* 6) FORM HANDLERS
***********************/
const form = document.getElementById('composer');
form.addEventListener('submit', (e) => { e.preventDefault(); handleUserText(textEl.value.trim()); });


/***********************
* 7) FIRST RUN MESSAGE
***********************/
addMessage('assistant', 'Hello! I\'m FRIDAY. Click the mic once to arm wake‑word listening, then say “Hey Friday …”. Or just type below.');
setStatus('Mic idle');
</script>
</body>
</html>
